# eliminination of cloud and undefined cells from MODIS data
# includes automatic sub-divisions of large rasters (to avoid memory problems)
# change interpolation to extrapolation for recent data.
# script version: 2012-03-26

library(rgdal)
library(raster)
options(warn=2)

# change settings here --------------------------------------------------
minf <- 4250 # first file to read, use lastl if known
maxf <- 4380 # last file to be read 
interval <- 150 # max number of files to be processed in one loop l
# max permitted number of cloudcells to save TIF as "cloudfree". 
maxc <- c(100,10000) # for cloud cells - threshold is raised for recent days
maxu <- 2000 # for undefined cells - higher value required if only 150 layers are to be processed
mncells <- 400000 # max number of cells per raster stack - proposed is 400000 for production

# set working directory = location of TIF files obtained from MODIS HDF
setwd('C:/AHT.PRO/Pakistan_Modelling/Data/Snowcover/MODIS/TIFs/')
# setwd('C:/AHT.PRO/Pakistan_Modelling/Counterparts/Tiffs/')

# end of code section with editable settings ----------------------------

# set array with defined values for MODIS.tif
# undecided, non-snow, cloud, snow, no-data
v <- c(1,25,50,200,255)
vp <- c(v[5],v[1],v[3],v[1]) # eliminate "undecided" twice, before and after cloud elimination
pl <- length(vp)
# define log file
logger <- "cloudelim.log"
write(as.character(Sys.time()),logger,append=T)
write(getwd(),logger,append=T)

note <- paste("Cloud eliminator - start routine:", format(Sys.time(),"%X"))
cat(note,"\n"); write(note,logger,append=T)

# load complete file list of TIFs into a R character vector
glist <- list.files(pattern="Snow_Cover_Daily_Tile.tif") 
xmlfiles <- list.files(pattern="xml")
glist <- glist[!glist %in% xmlfiles]  # remove xml files generated by gis application

totf <- length(glist) # total number of available files
firstl <- minf # settings for first loop
lastl <- min(interval+minf,totf,maxf)

# get raster properties
myr <- raster(glist[firstl])
myr_ncells <- myr@nrows*myr@ncols # total number of raster cells
ymin <- myr@extent@ymin
ymax <- myr@extent@ymax
xmin <- myr@extent@xmin
xmax <- myr@extent@xmax
n_slices <- ceiling(myr_ncells/mncells) # suggested number of sub-rasters
myr_nx <- xmax-xmin # extent(metres) of raster in x-direction
myr_nxr <- myr_nx/myr@ncols # resolution(cells) of raster in x-direction
slice_c <- ceiling(myr_nxr/n_slices) # width of slice in pixels
slice_m <- ceiling(myr_nx/n_slices/500)*500 # width of slices in m, rounded to next 500m
maxc <-maxc*n_slices # raise thresholds for large rasters
maxu <- maxu*n_slices

for (l in 1:40) {

    # recent allows extrapolation and output of all TIFs
    if (lastl>=totf) recent <-T else recent <- F 
	cat("loop #",l,"start file", glist[firstl],"\n")
    
	s <- stack(glist[firstl:lastl]) # add tifs to raster stack
    
	# add last previously processed layer to stack
    prevd <- 1
    
	if (minf>1) {
        while ( length(list.files(pattern=paste(substr(glist[minf-prevd],1,11),"tif",sep="")))==0 ) {
        prevd <- prevd + 1  
        } # end while
        s <- addLayer(s, paste(substr(glist[minf-prevd],1,11),"tif",sep="")) 
	} # end if 
    
    maxl <- nlayers(s)-1 # max number of layers
    
    # crop here raster-stack into slices
    for (slice in 1:n_slices){
        note <- paste("slice #",slice, "time: ",format(Sys.time(),"%X"))
        cat(note,"\n"); write(note,logger,append=T)
        
        ximin <- xmin+(slice-1)*slice_m
        ximax <- min(xmin+slice*slice_m, xmax)
        sextent <- extent(ximin,ximax,ymin,ymax)
        si <- crop(s,sextent)
        m <- as.matrix(si) # covert raster stack into 2d-matrix

        note <- paste("loop #",l,"process layers:", format(Sys.time(),"%X"))
        cat(note,"\n"); write(note,logger,append=T)
            
        for (i in 1:maxl){
            
            for (p in 1:pl) {
                cm <- which(m[,i]==vp[p],arr.ind = T) # indices of problem data values in matrix i
                for (rpos in cm) { # loop over cells with problem-data values
                    # find the next layer without (!=) problem-data at position rpos
                    cl <- which(m[rpos,i:maxl]!= vp[p])
                    if (length(cl)==0) next # exit if nothing found
                    il <- min(cl) + i-1
                    if (il == Inf) next # error trapping if no value found within range of layers
                    il1 <- il-1 # raster layer 1 above
                    rv <- as.integer(m[rpos,il]) # get next data raster value
                    
                    # interpolate raster values and substitute problem data cells
                    if (i > 1) r0 <- as.integer(m[rpos,i-1]) else {  # assign r0 to value of previous layer if possible
                        if (minf >1) r0 <- as.integer(m[rpos,maxl+1])  # assign r0 to previously processed value 
                        else r0 <- rv  # for the very first day there exists no previous value
                    } 
                    # make missing values (NA) to undefined (1)
                    if (is.na(r0)) r0 <- 1  
                    
                    if (r0 != rv) {
                        i1 <- floor((il-i)/2) + i
                        m[rpos,1:i1] <- r0
                        i1 <- i1+1
                        m[rpos,i1:il1] <- rv
                    } # end if
                    else m[rpos,i:il1] <- r0
                } # end of loop rpos for problem data cells in layer i
                                
            }  # end of loop p for problem data types
            
        }  # end loop i to process raster layers
        
        if (recent==T){
            cm <- which(m[,maxl]==vp[3],arr.ind = T)
            for (rpos in cm) { # loop over cells with problem-data values
                # find the first layer without (!=) problem-data at position rpos
                cl <- which(m[rpos,maxl:1]!= vp[3])
                if (length(cl)==0) next # exit if nothing found
                il <- maxl - min(cl) +1 # last day with no cloud cover in cell
                rv <- m[rpos,il]
                m[rpos,maxl:il] <- rv
            } # end rpos
        } # end extrapolation
        
        note <- paste("loop #",l,"convert matrix back to rasters:", format(Sys.time(),"%X"))
        cat(note,"\n"); write(note,logger,append=T)
        
        so <- setValues(si, m)    # convert matrix to raster brick
        sooi <- stack(so)         # convert raster brick to raster stack - data access is much faster than on brick
    
        # merge raster-stacks here
        if (slice==1) soo <- sooi else soo <- merge(soo,sooi)
    } # end of slices

	cat("loop #",l,"start output of rasters to disk:", format(Sys.time(),"%X"), "\n")
    
    if (lastl==maxf) r <- 2 else r <- 1
    irl <- 1 # index of layers in raster stack
    
	for (fi in minf:maxf){    # index of file names in glist
      if (count(subset(soo,irl),50) > maxc[r]) next       # exit if more than maxc cloud cells
      if (count(subset(soo,irl),1) > maxu) next           # exit if more than maxu undecided cells
      if (is.na(glist[(firstl+irl-1)])) next
	  rname <- paste(substr(glist[firstl+irl-1],1,11),"tif",sep="")  # generate new file name
	  # write cloud-free raster to new file on disk
      # filename determines format (geotiff), LZW compression by default
      # INT1U = unsigned 8-bit integer
	  writeRaster(subset(soo, irl, drop=TRUE),rname, datatype="INT1U", overwrite=TRUE)  
      note <- paste("file",rname,"- cloud cells=",count(subset(soo,irl),50))
      write(note,logger,append=T)
	  irl <- irl +1
      if (irl > nlayers(soo)) break
	} # end of fi

	cat(irl-1, "layers processed","\n")
    cat("last day:", substr(glist[firstl+irl-1],1,10), ", layer #", firstl+irl-1,"\n")
    cat("maxc=",maxc[r],"cloud cells in last raster: ", count(subset(soo,irl-1),50),"\n")
    note <- paste("loop #",l,"completed:", format(Sys.time(),"%X"))
    cat(note,"\n"); write(note,logger,append=T)
    
    if (r==2) break
    if (recent==T) break
    
    firstl <- firstl+irl-2 #  next routine starts with this layer
    lastl <- min(min(maxf,totf), (firstl+interval))
  
} # end loop l
options(warn=0)
